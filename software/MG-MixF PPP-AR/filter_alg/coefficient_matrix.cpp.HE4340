#include "coefficient_matrix.h"

coefficient_matrix::coefficient_matrix()
{

}
void coefficient_matrix::init_CoeffVar()
{
    isInitPara = false;//The first epoch is only initialized once
    m_VarChang = false;
    const_parm = 5 ;//[dx,dy,dz,mf,clki]
    sys_num = 1;
    m_sys_str = "G";
    lambda_radio =0;
    for(int i=0;i<4;i++)    Dops[i]=0;
    for(int i=0;i<5;i++)    IF0_combination[i] = 0;
    for(int i=0;i<5;i++)    IF1_combination[i] = 1;
    IF1_combination[1] = 1;//
    int sys_N = m_sys_str.length();
    if(m_sys_str.contains("C",Qt::CaseInsensitive))
        sys_N++;
    sys_len.resize(sys_N);
    sys_len.setZero(sys_N);
    filter_model = PPP_KINEMATIC_KALM;
    m_SPP_Pos[0] = m_SPP_Pos[1]= m_SPP_Pos[2] = 0;
    State_X.resize(32);
    State_X.setZero(32);
    sigma0 = 1.0;
    Combination_mode = Comb_IF_mode;
    whihet_diff = 1e4;
    xyz_kinematic = 1e3; trop_covarQ = 3e-8; rcv_clkQ = 1e6; sat_ambQ = 1e-12; sat_ionQ = 1e6;
    xyz_static = 100; trop_covarP = 10; rcv_clkP = 1e6; sat_ambP = 1e6; sat_ionP = 10;
}
//Initialize matrix
void coefficient_matrix::init_IF_matrix(int Avai_satN,MatrixXd &Coef_B,VectorXd &Obs_L)
{
    const_parm = 4+sys_num;

    switch (filter_model) {
    case PPP_STATIC_SRIF:
    case PPP_KINEMATIC_SRIF:
        State_X.resize(Avai_satN+const_parm);
        State_X.setZero(Avai_satN+const_parm);
        Covar_P.resize(Avai_satN+const_parm,Avai_satN+const_parm);
        Covar_P.setZero(Avai_satN+const_parm,Avai_satN+const_parm);
        Nois_Q.resize(Avai_satN+const_parm,Avai_satN+const_parm);
        Nois_Q.setZero(Avai_satN+const_parm,Avai_satN+const_parm);
        if(filter_model==PPP_STATIC_SRIF)
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_static;
            }
        }
        else
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_kinematic;
                Nois_Q(i,i) = xyz_kinematic;
            }

        }
        Covar_P(3,3) = trop_covarP;Nois_Q(3,3) = trop_covarP;
        for(int i=4;i<const_parm;i++)
        {
            Covar_P(i,i) = rcv_clkP;
            Nois_Q(i,i) = rcv_clkP;
        }
        for(int i=const_parm;i<Covar_P.cols();i++)
        {
            Covar_P(i,i) = sat_ambP;
            Nois_Q(i,i) = sat_ambP;
        }
        break;
    case PPP_STATIC_KALM:
    case PPP_KINEMATIC_KALM:
        State_X.resize(Avai_satN+const_parm);
        State_X.setZero(Avai_satN+const_parm);
        Nois_Q.resize(Avai_satN+const_parm,Avai_satN+const_parm);
        Nois_Q.setZero(Avai_satN+const_parm,Avai_satN+const_parm);
        Covar_P.resize(Avai_satN+const_parm,Avai_satN+const_parm);
        Covar_P.setZero(Avai_satN+const_parm,Avai_satN+const_parm);
        state_Fi.resize(Avai_satN+const_parm,Avai_satN+const_parm);
        state_Fi.setIdentity(Avai_satN+const_parm,Avai_satN+const_parm);

        Covar_P(3,3) = trop_covarP;Nois_Q(3,3) = trop_covarQ;
        for(int i=4;i<const_parm;i++)
        {
            Covar_P(i,i) = rcv_clkP;Nois_Q(i,i) = rcv_clkQ;
        }
        for(int i=const_parm;i<Nois_Q.cols();i++)
        {
            Covar_P(i,i) = sat_ambP; Nois_Q(i,i) =sat_ambQ;
        }
        if(filter_model==PPP_KINEMATIC_KALM)
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_kinematic;
                Nois_Q(i,i) = xyz_kinematic;
            }
        }
        else
        {
            for(int i=0;i<3;i++)    Covar_P(i,i) = xyz_static;
        }
        break;
    default:
        break;
    }
    State_X = (Coef_B.transpose()*Coef_B).inverse()*Coef_B.transpose()*Obs_L;
    isInitPara = true;//No longer initialized after
}
void coefficient_matrix::init_NOcombina_matrix(QVector< SatlitData > &Current_sat,MatrixXd &Coef_B,VectorXd &Obs_L,int Total_sat_fre)
{
    const_parm = 4+sys_num;
    int Avai_satN = Current_sat.length();
    int PAcoeff = 0,PAcoeff1 = 0;
    switch (filter_model) {
    case PPP_STATIC_SRIF:
    case PPP_KINEMATIC_SRIF:
        State_X.resize(Avai_satN+const_parm+Total_sat_fre);
        State_X.setZero(Avai_satN+const_parm+Total_sat_fre);
        Covar_P.resize(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Covar_P.setZero(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Nois_Q.resize(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Nois_Q.setZero(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);

        if(filter_model==PPP_STATIC_SRIF)
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_static;
            }
        }
        else
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_kinematic;
                Nois_Q(i,i) = xyz_kinematic;
            }

        }
        Covar_P(3,3) = trop_covarP;Nois_Q(3,3) = trop_covarP;
        for(int i=4;i<const_parm;i++)
        {
            Covar_P(i,i) = rcv_clkP;
            Nois_Q(i,i) = rcv_clkP;
        }
        for(int i = 0; i < Avai_satN;i++)
        {
            SatlitData Pelement = Current_sat.at(i);
            int coeffI=PAcoeff1;
            PAcoeff1++;
            for(int mufre=0;mufre<5;mufre++)
            {
                if(Pelement.ObsFreflag[mufre]!=1)  continue;
                Nois_Q(coeffI+const_parm,coeffI+const_parm) = sat_ionP;
                Nois_Q(PAcoeff1+const_parm,PAcoeff1+const_parm) = sat_ambP;
                Covar_P(coeffI+const_parm,coeffI+const_parm) = sat_ionP;
                Covar_P(PAcoeff1+const_parm,PAcoeff1+const_parm) = sat_ambP;// for Ambiguity
                PAcoeff1++;
            }
        }
        break;
    case PPP_STATIC_KALM:
    case PPP_KINEMATIC_KALM:
        State_X.resize(Avai_satN+const_parm+Total_sat_fre);
        State_X.setZero(Avai_satN+const_parm+Total_sat_fre);
        Nois_Q.resize(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Nois_Q.setZero(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Covar_P.resize(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        Covar_P.setZero(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        state_Fi.resize(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);
        state_Fi.setIdentity(Avai_satN+const_parm+Total_sat_fre,Avai_satN+const_parm+Total_sat_fre);

        Covar_P(3,3) = Nois_Q(3,3) = trop_covarP;
        for(int i=4;i<const_parm;i++)
            Covar_P(i,i) = Nois_Q(i,i) = rcv_clkP;

        for(int i = 0; i < Avai_satN;i++)
        {
            SatlitData Pelement = Current_sat.at(i);
            int coeffI=PAcoeff;
            PAcoeff++;
            for(int mufre=0;mufre<5;mufre++)
            {
                if(Pelement.ObsFreflag[mufre]!=1)  continue;
                Nois_Q(coeffI+const_parm,coeffI+const_parm) = sat_ionQ;
                Nois_Q(PAcoeff+const_parm,PAcoeff+const_parm) = sat_ambQ;
                Covar_P(coeffI+const_parm,coeffI+const_parm) = sat_ionP;
                Covar_P(PAcoeff+const_parm,PAcoeff+const_parm) = sat_ambP;// for Ambiguity
                PAcoeff++;
            }
        }
        for(int i=const_parm;i<Nois_Q.cols();i++)
        {
            Covar_P(i,i) = sat_ambP;Nois_Q(i,i) =sat_ambQ;
        }
        if(filter_model==PPP_KINEMATIC_KALM)
        {
            for(int i=0;i<3;i++)
            {
                Covar_P(i,i) = xyz_kinematic;
                Nois_Q(i,i) = xyz_kinematic;
            }
        }
        else
        {
            for(int i=0;i<3;i++)    Covar_P(i,i) = xyz_static;
        }
        break;
    default:
        break;
    }
    State_X = (Coef_B.transpose()*Coef_B).inverse()*Coef_B.transpose()*Obs_L;
    isInitPara = true;//No longer initialized after
}
// get matrix B and observer L for IF Combination
void coefficient_matrix::Obtaining_IF_equation(QVector< SatlitData > &Current_sat, double *m_ApproxRecPos, MatrixXd &mat_B, VectorXd &Vct_L,
                             MatrixXd &mat_P)
{
    int Avai_satN = Current_sat.length();
    MatrixXd B, P;
    VectorXd L;
    const_parm = 4+sys_num;
    switch(filter_model)
    {
    case PPP_STATIC_SRIF:
    case PPP_KINEMATIC_SRIF:
    case PPP_STATIC_KALM:
    case PPP_KINEMATIC_KALM:
        B.resize(Avai_satN*2,Avai_satN+const_parm);
        P.resize(Avai_satN*2,Avai_satN*2);
        L.resize(Avai_satN*2);
        B.setZero(Avai_satN*2,Avai_satN+const_parm);
        L.setZero(Avai_satN*2);
        P.setIdentity();
        break;
    default:
        ErroTrace("Obtaining_IF_equation you should use setModel().");
        break;
    }
    for (int i = 0; i < Avai_satN;i++)
    {
        SatlitData oneSatlit = Current_sat.at(i);
        double XYZ_coef[3],p0 = 0,satXYZ[3]={oneSatlit.X,oneSatlit.Y,oneSatlit.Z};
//        p0 = m_mat_cal.geodist(satXYZ,m_ApproxRecPos,XYZ_coef);
        double li = 0,mi = 0,ni = 0,dltaX = 0,dltaY = 0,dltaZ = 0;
        dltaX = oneSatlit.X - m_ApproxRecPos[0];
        dltaY = oneSatlit.Y - m_ApproxRecPos[1];
        dltaZ = oneSatlit.Z - m_ApproxRecPos[2];
        p0 = qSqrt(dltaX*dltaX+dltaY*dltaY+dltaZ*dltaZ);
        // compute li mi ni
        li = dltaX/p0;mi = dltaY/p0;ni = dltaZ/p0;
        //Correction of each
        double dlta = 0;
        dlta =  - oneSatlit.StaClock + oneSatlit.SatTrop - oneSatlit.Relativty -
            oneSatlit.Sagnac - oneSatlit.TideEffect - oneSatlit.AntHeight;
        // set B L P
        int clk_ref=0,bds_flag=0;
        switch(filter_model)
        {
        case PPP_STATIC_SRIF:
        case PPP_KINEMATIC_SRIF:
        case PPP_STATIC_KALM:
        case PPP_KINEMATIC_KALM:
            //Computational B matrix
            //L3 carrier matrix
//            for(int j=0;j<3;j++)
//            {
//                B(i*2,j) = XYZ_coef[j];
//                B(i*2+1,j) = XYZ_coef[j];
//            }
            B(i*2,0) = li;B(i*2,1) = mi;B(i*2,2) = ni;
            B(i*2+1,0) = li;B(i*2+1,1) = mi;B(i*2+1,2) = ni;
            B(i*2,3) = -oneSatlit.StaTropMap;
            B(i*2+1,3) = -oneSatlit.StaTropMap;

            for(int j=0;j<m_sys_str.length();j++)
            {
                if(m_sys_str[j] == oneSatlit.SatType&&oneSatlit.SatType=='C'&&oneSatlit.BDS_2flag)
                {
                    B(i*2,4+clk_ref) = -1;
                    B(i*2+1,4+clk_ref) = -1;
                }
                else if(m_sys_str[j] == oneSatlit.SatType&&oneSatlit.SatType=='C')
                {
                    if(sys_len[j]==1)   clk_ref++;
                    B(i*2,4+clk_ref) = -1;
                    B(i*2+1,4+clk_ref) = -1;
                }
                else if(m_sys_str[j] == oneSatlit.SatType)
                {
                    B(i*2,4+clk_ref) = -1;
                    B(i*2+1,4+clk_ref) = -1;
                }
                if(m_sys_str[j]=='C')
                {
                    if(sys_len[j] == 1) clk_ref++;
                    bds_flag++;
                    if(sys_len[j+bds_flag] == 1) clk_ref++;
                }
                else
                    if(sys_len[j+bds_flag] == 1) clk_ref++;
            }
            for (int n = 0;n < Avai_satN;n++)//The diagonal part of the rear part initializes the wavelength of Lamta3, and the rest is 0.
                if (i == n)
                    B(i*2,const_parm+n) = M_GetLamta3(oneSatlit.Frq[oneSatlit.IF_Frq[0]],oneSatlit.Frq[oneSatlit.IF_Frq[1]]);//LL3 wavelength
            //Carrier L  pseudorange code L
            L(i*2) = p0 - oneSatlit.IF_L + dlta;
            L(i*2+1) = p0 - oneSatlit.IF_P + dlta;
            // Computing weight matrix P
            P(i*2, i*2) = oneSatlit.SatWight * whihet_diff*oneSatlit.SatWight_IF[0];// Carrier L1 weight
            P(i*2+1, i*2+1) = oneSatlit.SatWight *oneSatlit.SatWight_IF[1];// Carrier L2 weight
            break;
        default:
            ErroTrace("Obtaining_equation you should use setModel().");
            break;
        }

    }//B, L is calculated
    // save data to mat_B
    mat_B = B;
    Vct_L = L;
    mat_P = P;
}
// get matrix B and observer L for No Combination
void coefficient_matrix::Obtaining_NoCombination_equation(QVector< SatlitData > &Current_sat, double *m_ApproxRecPos, MatrixXd &mat_B, VectorXd &Vct_L,
                             MatrixXd &mat_P,int Total_sat_fre)
{
    int Avai_satN = Current_sat.length();
    MatrixXd B, P;
    VectorXd L;
    const_parm = 4+sys_num;
    switch(filter_model)
    {
    case PPP_STATIC_SRIF:
    case PPP_KINEMATIC_SRIF:
    case PPP_STATIC_KALM:
    case PPP_KINEMATIC_KALM:
        B.resize(Total_sat_fre*2,const_parm+Avai_satN+Total_sat_fre);
        P.resize(Total_sat_fre*2,Total_sat_fre*2);
        L.resize(Total_sat_fre*2);
        B.setZero(Total_sat_fre*2,const_parm+Avai_satN+Total_sat_fre);
        L.setZero(Total_sat_fre*2);
        P.setIdentity();
        break;
    default:
        ErroTrace("Obtaining_IF_equation you should use setModel().");
        break;
    }
    int column_pos =0;
    for (int i = 0; i < Avai_satN;i++)
    {
        SatlitData oneSatlit = Current_sat.at(i);
        double XYZ_coef[3],p0 = 0,satXYZ[3]={oneSatlit.X,oneSatlit.Y,oneSatlit.Z};
        p0 = m_mat_cal.geodist(satXYZ,m_ApproxRecPos,XYZ_coef);
        //Correction of each
        double dlta = 0;
        dlta =  - oneSatlit.StaClock + oneSatlit.SatTrop - oneSatlit.Relativty -
            oneSatlit.Sagnac - oneSatlit.TideEffect - oneSatlit.AntHeight;
        // set B L P
        int coeffI=column_pos,one_fre = 0;
        double fre1=0,fre_n=0;int clk_ref=0,bds_flag=0;
        switch(filter_model)
        {
        case PPP_STATIC_SRIF:
        case PPP_KINEMATIC_SRIF:
        case PPP_STATIC_KALM:
        case PPP_KINEMATIC_KALM:
            //Computational B matrix
            //L3 carrier matrix
            for(int mufre=0;mufre<5;mufre++)
            {
                if(oneSatlit.ObsFreflag[mufre]!=1)  continue;
                for(int j=0;j<3;j++)
                {
                    B(column_pos*2,j) = XYZ_coef[j];
                    B(column_pos*2+1,j) = XYZ_coef[j];
                }
                B(column_pos*2,3) = -oneSatlit.StaTropMap;
                B(column_pos*2+1,3) = -oneSatlit.StaTropMap;

                for(int j=0;j<m_sys_str.length();j++)
                {
                    if(m_sys_str[j] == oneSatlit.SatType&&oneSatlit.SatType=='C'&&oneSatlit.BDS_2flag)
                    {
                        B(column_pos*2,4+clk_ref) = -1;
                        B(column_pos*2+1,4+clk_ref) = -1;
                    }
                    else if(m_sys_str[j] == oneSatlit.SatType&&oneSatlit.SatType=='C')
                    {
                        if(sys_len[j]==1)   clk_ref++;
                        B(column_pos*2,4+clk_ref) = -1;
                        B(column_pos*2+1,4+clk_ref) = -1;
                    }
                    else if(m_sys_str[j] == oneSatlit.SatType)
                    {
                        B(column_pos*2,4+clk_ref) = -1;
                        B(column_pos*2+1,4+clk_ref) = -1;
                    }
                    if(m_sys_str[j]=='C')
                    {
                        if(sys_len[j] == 1) clk_ref++;
                        bds_flag++;
                        if(sys_len[j+bds_flag] == 1) clk_ref++;
                    }
                    else
                        if(sys_len[j+bds_flag] == 1) clk_ref++;
                }
                if(one_fre == 0)
                {
                    one_fre = 1;
                    fre1 = oneSatlit.Frq[mufre];
                }
                fre_n = oneSatlit.Frq[mufre];
                B(column_pos*2,const_parm+coeffI+i) = (fre1*fre1)/(fre_n*fre_n);
                B(column_pos*2,const_parm+column_pos+i+1) = oneSatlit.Lambda[mufre];
                B(column_pos*2+1,const_parm+coeffI+i) = -(fre1*fre1)/(fre_n*fre_n);
                //Carrier L  pseudorange code L
                L(column_pos*2) = p0 - oneSatlit.PhaseLL[mufre] + dlta;
                L(column_pos*2+1) = p0 - oneSatlit.CodePP[mufre] + dlta;
                // Computing weight matrix P
                P(column_pos*2, column_pos*2) = oneSatlit.SatWight * whihet_diff *oneSatlit.SatWight_UD[2*mufre];// Carrier L1 weight
                P(column_pos*2+1, column_pos*2+1) = oneSatlit.SatWight*oneSatlit.SatWight_UD[2*mufre+1];// Carrier L2 weight
                column_pos++;
            }
            break;
        default:
            ErroTrace("Obtaining_equation you should use setModel().");
            break;
        }

    }//B, L is calculated
    // save data to mat_B
    mat_B = B;
    Vct_L = L;
    mat_P = P;

}
//Change the parameter size (only PPP can change paramater)
void coefficient_matrix::change_IF_Paramatrix(QVector< SatlitData > &preEpoch, QVector< SatlitData > &current_Sat,
                                              QVector< int >oldPrnFlag,int preEpochLen,QVector< int > &NewPrnFlag)
{
    int Avai_satN = current_Sat.length();
//MU_num Number of ambiguity szg  Avai_satN Number of ionosphere unknowns
    state_Fi.resize(const_parm+Avai_satN,const_parm+Avai_satN);
    state_Fi.setIdentity();

    VectorXd tempXk_1 = State_X;
    MatrixXd tempPk_1 = Covar_P;
    MatrixXd tempQk_1 = Nois_Q;
    State_X.resize(Avai_satN+const_parm);
    State_X.setZero(Avai_satN+const_parm);
    Covar_P.resize(Avai_satN+const_parm, Avai_satN+const_parm);
    Nois_Q.resize(Avai_satN+const_parm, Avai_satN+const_parm);

    int clk_n =0;
    for(int i=0;i<sys_len.size();i++)
    {
        if(sys_len[i]==up_sys_len[i]&&up_sys_len[i]==1)
        {
            clk_n++;
        }
        else if(sys_len[i]==1)
        {
            VectorXd head_Xn = tempXk_1.head(4+clk_n);
            VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-4-clk_n);
            tempXk_1.resize(head_Xn.size()+tail_Xn.size()+1);//szg
            tempXk_1.head(head_Xn.size()) = head_Xn;
            tempXk_1.tail(tail_Xn.size()) = tail_Xn;
            tempXk_1(4+clk_n) = tempXk_1(4);
            int Pkcols=tempPk_1.cols();

            MatrixXd tempPk_2;
            tempPk_2.resize(Pkcols+1,Pkcols+1);
            tempPk_2.setZero(Pkcols+1,Pkcols+1);
            tempPk_2.block(0,0,4+clk_n,4+clk_n) = tempPk_1.block(0,0,4+clk_n,4+clk_n);
            tempPk_2.block(5+clk_n,5+clk_n,Pkcols-4-clk_n,Pkcols-4-clk_n) = tempPk_1.block(4+clk_n,4+clk_n,Pkcols-4-clk_n,Pkcols-4-clk_n);
            tempPk_2.block(5+clk_n,0,Pkcols-4-clk_n,4+clk_n) = tempPk_1.block(4+clk_n,0,Pkcols-4-clk_n,4+clk_n);
            tempPk_2.block(0,5+clk_n,4+clk_n,Pkcols-4-clk_n) = tempPk_1.block(0,4+clk_n,4+clk_n,Pkcols-4-clk_n);
            tempPk_2(4+clk_n,4+clk_n) = rcv_clkP;
            int Pk2cols=tempPk_2.cols();
            tempPk_1.resize(Pk2cols,Pk2cols);
            tempPk_1 = tempPk_2;

            MatrixXd tempQk_2;
            int Qk1cols = tempQk_1.cols();
            tempQk_2.resize(Qk1cols+1,Qk1cols+1);
            tempQk_2.setZero(Qk1cols+1,Qk1cols+1);
            tempQk_2.block(0,0,4+clk_n,4+clk_n) = tempQk_1.block(0,0,4+clk_n,4+clk_n);
            tempQk_2.block(5+clk_n,5+clk_n,Qk1cols-4-clk_n,Qk1cols-4-clk_n) = tempQk_1.block(4+clk_n,4+clk_n,Qk1cols-4-clk_n,Qk1cols-4-clk_n);
            tempQk_2(4+clk_n,4+clk_n) = rcv_clkQ;
            int Qk2cols = tempQk_2.cols();
            tempQk_1.resize(Qk2cols,Qk2cols);
            tempQk_1 = tempQk_2;
            clk_n++;
        }
        else if(up_sys_len[i]==1)
        {
            VectorXd head_Xn = tempXk_1.head(4+clk_n);
            VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-4-clk_n-1);
            tempXk_1.resize(head_Xn.size()+tail_Xn.size());//szg
            tempXk_1<<head_Xn,tail_Xn;
            m_mat_cal.RemoveRow(tempQk_1,4+clk_n);
            m_mat_cal.RemoveColumn(tempQk_1,4+clk_n);
            m_mat_cal.RemoveRow(tempPk_1,4+clk_n);
            m_mat_cal.RemoveColumn(tempPk_1,4+clk_n);
        }
    }
    int lenVR = const_parm;
    for(int i = 0;i<preEpochLen;i++)
    {
        if(NewPrnFlag.at(i)!=-1)
        {
            lenVR++;
        }
        else
        {
            if(lenVR == tempXk_1.size()-1)
            {
                VectorXd head_Xn = tempXk_1.head(lenVR);
                tempXk_1.resize(head_Xn.size());
                tempXk_1=head_Xn;
            }
            else
            {
                VectorXd head_Xn = tempXk_1.head(lenVR);
                VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-lenVR-1);
                tempXk_1.resize(head_Xn.size()+tail_Xn.size());//szg
                tempXk_1<<head_Xn,tail_Xn;
            }
            m_mat_cal.RemoveRow(tempQk_1,lenVR);
            m_mat_cal.RemoveColumn(tempQk_1,lenVR);
            m_mat_cal.RemoveRow(tempPk_1,lenVR);
            m_mat_cal.RemoveColumn(tempPk_1,lenVR);
        }
    }
    for (int n = 0; n < Avai_satN;n++)
    {
        SatlitData oneStalit = current_Sat.at(n);
        if (oldPrnFlag.at(n) == -1)
        {
            if(n==Avai_satN-1)
            {
                VectorXd head_Xn = tempXk_1.head(const_parm+n);
                tempXk_1.resize(tempXk_1.size()+1);
                tempXk_1.head(head_Xn.size()) = head_Xn;
                tempXk_1(const_parm+n) = (oneStalit.IF_P - oneStalit.IF_L)/M_GetLamta3(oneStalit.Frq[oneStalit.IF_Frq[0]],oneStalit.Frq[oneStalit.IF_Frq[1]]);
                MatrixXd tempPk_2;
                int Pkcols=tempPk_1.cols();
                tempPk_2.resize(Pkcols+1,Pkcols+1);
                tempPk_2.setZero(Pkcols+1,Pkcols+1);
                tempPk_2.block(0,0,const_parm+n,const_parm+n) = tempPk_1.block(0,0,const_parm+n,const_parm+n);
                tempPk_2(const_parm+n,const_parm+n) = sat_ambP;
                int Pk2cols=tempPk_2.cols();
                tempPk_1.resize(Pk2cols,Pk2cols);
                tempPk_1 = tempPk_2;
                MatrixXd tempQk_2;
                int Qk1cols = tempQk_1.cols();
                tempQk_2.resize(Qk1cols+1,Qk1cols+1);
                tempQk_2.setZero(Qk1cols+1,Qk1cols+1);
                tempQk_2.block(0,0,const_parm+n,const_parm+n) = tempQk_1.block(0,0,const_parm+n,const_parm+n);
                tempQk_2(const_parm+n,const_parm+n) = sat_ambQ;
                int Qk2cols = tempQk_2.cols();
                tempQk_1.resize(Qk2cols,Qk2cols);
                tempQk_1 = tempQk_2;
            }
            else
            {
                VectorXd head_Xn = tempXk_1.head(const_parm+n);
                VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-const_parm-n);
                tempXk_1.resize(tempXk_1.size()+1);
                tempXk_1.head(head_Xn.size()) = head_Xn;
                tempXk_1.tail(tail_Xn.size()) = tail_Xn;
                tempXk_1(const_parm+n) = (oneStalit.IF_P - oneStalit.IF_L)/M_GetLamta3(oneStalit.Frq[oneStalit.IF_Frq[0]],oneStalit.Frq[oneStalit.IF_Frq[1]]);
                MatrixXd tempPk_2;
                int Pkcols=tempPk_1.cols();
                tempPk_2.resize(Pkcols+1,Pkcols+1);
                tempPk_2.setZero(Pkcols+1,Pkcols+1);
                tempPk_2.block(0,0,const_parm+n,const_parm+n) = tempPk_1.block(0,0,const_parm+n,const_parm+n);
                tempPk_2.block(0,const_parm+n+1,const_parm+n,Pkcols-const_parm-n) = tempPk_1.block(0,const_parm+n,const_parm+n,Pkcols-const_parm-n);
                tempPk_2.block(const_parm+n+1,0,Pkcols-const_parm-n,const_parm+n) = tempPk_1.block(const_parm+n,0,Pkcols-const_parm-n,const_parm+n);
                tempPk_2.block(const_parm+n+1,const_parm+n+1,Pkcols-const_parm-n,Pkcols-const_parm-n) = tempPk_1.block(const_parm+n,const_parm+n,Pkcols-const_parm-n,Pkcols-const_parm-n);
                tempPk_2(const_parm+n,const_parm+n) = sat_ambP;
                int Pk2cols=tempPk_2.cols();
                tempPk_1.resize(Pk2cols,Pk2cols);
                tempPk_1 = tempPk_2;
                MatrixXd tempQk_2;
                int Qk1cols = tempQk_1.cols();
                tempQk_2.resize(Qk1cols+1,Qk1cols+1);
                tempQk_2.setZero(Qk1cols+1,Qk1cols+1);
                tempQk_2.block(0,0,const_parm+n,const_parm+n) = tempQk_1.block(0,0,const_parm+n,const_parm+n);
                tempQk_2.block(const_parm+n+1,const_parm+n+1,Qk1cols-const_parm-n,Qk1cols-const_parm-n) = tempQk_1.block(const_parm+n,const_parm+n,Qk1cols-const_parm-n,Qk1cols-const_parm-n);
                tempQk_2(const_parm+n,const_parm+n) = sat_ambQ;
                int Qk2cols = tempQk_2.cols();
                tempQk_1.resize(Qk2cols,Qk2cols);
                tempQk_1 = tempQk_2;
            }
        }
        else if(oneStalit.cycly_slipF == 1)
        {
            tempXk_1(const_parm+n) = (oneStalit.IF_P - oneStalit.IF_L)/M_GetLamta3(oneStalit.Frq[oneStalit.IF_Frq[0]],oneStalit.Frq[oneStalit.IF_Frq[1]]);
            for(int j=0;j<tempXk_1.size();j++)
            {
                if(const_parm+n == j)
                    tempPk_1(const_parm+n,const_parm+n)=sat_ambP;
                else
                {
                    tempPk_1(const_parm+n,j) = 0;
                    tempPk_1(j,const_parm+n) = 0;
                }
            }
        }

    }
    int Pkcols=tempPk_1.cols();
    if(Covar_P.cols()!=Pkcols)
        return;
    Covar_P = tempPk_1;
    State_X = tempXk_1;
    Nois_Q = tempQk_1;
    m_VarChang = true;
}
//Change the parameter size (only PPP can change paramater)
void coefficient_matrix::change_NoCombination_Para(QVector< SatlitData > &preEpoch, QVector< SatlitData > &current_Sat,
                                              QVector< int >oldPrnFlag,int preEpochLen,QVector< int > &NewPrnFlag,int Total_sat_fre)
{
    int Avai_satN = current_Sat.length();
//MU_num Number of ambiguity szg  Avai_satN Number of ionosphere unknowns
    state_Fi.resize(const_parm+Total_sat_fre+Avai_satN,const_parm+Total_sat_fre+Avai_satN);
    state_Fi.setIdentity();

    VectorXd tempXk_1 = State_X;
    MatrixXd tempPk_1 = Covar_P;
    MatrixXd tempQk_1 = Nois_Q;
    State_X.resize(const_parm+Total_sat_fre+Avai_satN);
    State_X.setZero(const_parm+Total_sat_fre+Avai_satN);
    Covar_P.resize(const_parm+Total_sat_fre+Avai_satN, const_parm+Total_sat_fre+Avai_satN);
    Nois_Q.resize(const_parm+Total_sat_fre+Avai_satN, const_parm+Total_sat_fre+Avai_satN);

    int clk_n =0;
    for(int i=0;i<sys_len.size();i++)
    {
        if(sys_len[i]==up_sys_len[i]&&up_sys_len[i]==1)
        {
            clk_n++;
        }
        else if(sys_len[i]==1)
        {
            tempXk_1(4+clk_n) = tempXk_1(4);
            MatrixXd tempPk_2;
            int Pkcols=tempPk_1.cols();
            tempPk_2.resize(Pkcols+1,Pkcols+1);
            tempPk_2.setZero(Pkcols+1,Pkcols+1);
            tempPk_2.block(0,0,4+clk_n,4+clk_n) = tempPk_1.block(0,0,4+clk_n,4+clk_n);
            tempPk_2.block(5+clk_n,5+clk_n,Pkcols-4-clk_n,Pkcols-4-clk_n) = tempPk_1.block(4+clk_n,4+clk_n,Pkcols-4-clk_n,Pkcols-4-clk_n);
            tempPk_2.block(5+clk_n,0,Pkcols-5-clk_n,4+clk_n) = tempPk_1.block(4+clk_n,0,Pkcols-4-clk_n,4+clk_n);
            tempPk_2.block(0,5+clk_n,4+clk_n,Pkcols-5-clk_n) = tempPk_1.block(0,4+clk_n,4+clk_n,Pkcols-4-clk_n);
            tempPk_2(4+clk_n,4+clk_n) = rcv_clkP;
            int Pk2cols=tempPk_2.cols();
            tempPk_1.resize(Pk2cols,Pk2cols);
            tempPk_1 = tempPk_2;
            MatrixXd tempQk_2;
            int Qk1cols = tempQk_1.cols();
            tempQk_2.resize(Qk1cols+1,Qk1cols+1);
            tempQk_2.setZero(Qk1cols+1,Qk1cols+1);
            tempQk_2.block(0,0,4+clk_n,4+clk_n) = tempQk_1.block(0,0,4+clk_n,4+clk_n);
            tempQk_2.block(5+clk_n,5+clk_n,Qk1cols-4-clk_n,Qk1cols-4-clk_n) = tempQk_1.block(4+clk_n,4+clk_n,Qk1cols-4-clk_n,Qk1cols-4-clk_n);
            tempQk_2(4+clk_n,4+clk_n) = rcv_clkQ;
            int Qk2cols = tempQk_2.cols();
            tempQk_1.resize(Qk2cols,Qk2cols);
            tempQk_1 = tempQk_2;
            clk_n++;
        }
        else if(up_sys_len[i]==1)
        {
            VectorXd head_Xn = tempXk_1.head(4+i);
            VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-4-i);
            tempXk_1.resize(head_Xn.size()+tail_Xn.size());//szg
            tempXk_1<<head_Xn,tail_Xn;
            m_mat_cal.RemoveRow(tempQk_1,4+i);
            m_mat_cal.RemoveColumn(tempQk_1,4+i);
            m_mat_cal.RemoveRow(tempPk_1,4+i);
            m_mat_cal.RemoveColumn(tempPk_1,4+i);
        }
    }
    int lenVR = const_parm;
    for(int i = 0;i<preEpochLen;i++)
    {
        SatlitData preStalit = preEpoch.at(i);
        int prefre = preStalit.ObsLenfre + 1;
        if(NewPrnFlag.at(i)!=-1)
        {
            lenVR=prefre+lenVR;
        }
        else
        {
            if(tempXk_1.size()-lenVR-prefre==0)
            {
                VectorXd head_Xn = tempXk_1.head(lenVR);
                tempXk_1.resize(head_Xn.size());
                tempXk_1=head_Xn;
            }
            else
            {
                VectorXd head_Xn = tempXk_1.head(lenVR);
                VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-lenVR-prefre);
                tempXk_1.resize(head_Xn.size()+tail_Xn.size());//szg
                tempXk_1<<head_Xn,tail_Xn;
            }

            for(int rem=0;rem<prefre;rem++)
            {
                m_mat_cal.RemoveRow(tempQk_1,lenVR);
                m_mat_cal.RemoveColumn(tempQk_1,lenVR);
                m_mat_cal.RemoveRow(tempPk_1,lenVR);
                m_mat_cal.RemoveColumn(tempPk_1,lenVR);
            }
        }
    }
    int freIn = const_parm;
    for (int n = 0; n < Avai_satN;n++)
    {
        SatlitData oneStalit = current_Sat.at(n);
        int Lenfre = oneStalit.ObsLenfre + 1;
        if (oldPrnFlag.at(n) == -1)
        {
            if(tempXk_1.size()-freIn==0)
            {
                VectorXd head_Xn = tempXk_1.head(freIn);
                tempXk_1.resize(tempXk_1.size()+Lenfre);
                tempXk_1.head(head_Xn.size()) = head_Xn;

                MatrixXd tempPk_2;
                int Pkcols=tempPk_1.cols();
                tempPk_2.resize(Pkcols+Lenfre,Pkcols+Lenfre);
                tempPk_2.setZero(Pkcols+Lenfre,Pkcols+Lenfre);
                MatrixXd tempQk_2;
                int Qk1cols = tempQk_1.cols();
                tempQk_2.resize(Qk1cols+Lenfre,Qk1cols+Lenfre);
                tempQk_2.setZero(Qk1cols+Lenfre,Qk1cols+Lenfre);
                int frequetN = 1;
                for(int j=0;j<5;j++)
                {
                    if(oneStalit.ObsFreflag[j]==1)
                    {
                        tempXk_1(freIn+frequetN) = (oneStalit.CodeP[j] - oneStalit.PhaseL[j])/(M_C/oneStalit.Frq[j]);
                        frequetN++;
                    }
                }
                for(int j=0;j<Lenfre;j++)
                {
                    if(j==0)
                    {
                        tempPk_2(freIn+j,freIn+j) =  sat_ionP;
                        tempQk_2(freIn+j,freIn+j) =  sat_ionQ;
                    }
                    else
                    {
                        tempPk_2(freIn+j,freIn+j) =  sat_ambP;
                        tempQk_2(freIn+j,freIn+j) =  sat_ambQ;
                    }
                }
                tempPk_2.block(0,0,freIn,freIn) = tempPk_1.block(0,0,freIn,freIn);
                int Pk2cols=tempPk_2.cols();
                tempPk_1.resize(Pk2cols,Pk2cols);
                tempPk_1 = tempPk_2;
                tempQk_2.block(0,0,freIn,freIn) = tempQk_1.block(0,0,freIn,freIn);
                int Qk2cols = tempQk_2.cols();
                tempQk_1.resize(Qk2cols,Qk2cols);
                tempQk_1 = tempQk_2;
            }
            else
            {
                VectorXd head_Xn = tempXk_1.head(freIn);
                VectorXd tail_Xn = tempXk_1.tail(tempXk_1.size()-freIn);
                tempXk_1.resize(tempXk_1.size()+Lenfre);
                tempXk_1.head(head_Xn.size()) = head_Xn;
                tempXk_1.tail(tail_Xn.size()) = tail_Xn;
                MatrixXd tempPk_2,transPCentre;
                int Pkcols=tempPk_1.cols();
                tempPk_2.resize(Pkcols+Lenfre,Pkcols+Lenfre);
                tempPk_2.setZero(Pkcols+Lenfre,Pkcols+Lenfre);
                transPCentre.resize(Lenfre,Lenfre);
                transPCentre.setZero(Lenfre,Lenfre);
                MatrixXd tempQk_2,transQCentre;
                int Qk1cols = tempQk_1.cols();
                tempQk_2.resize(Qk1cols+Lenfre,Qk1cols+Lenfre);
                tempQk_2.setZero(Qk1cols+Lenfre,Qk1cols+Lenfre);
                transQCentre.resize(Lenfre,Lenfre);
                transQCentre.setZero(Lenfre,Lenfre);
                int frequetN = 1;
                for(int j=0;j<5;j++)
                {
                    if(oneStalit.ObsFreflag[j]==1)
                    {
                        tempXk_1(freIn+frequetN) = (oneStalit.CodeP[j] - oneStalit.PhaseL[j])/(M_C/oneStalit.Frq[j]);
                        frequetN++;
                    }
                }
                for(int j=0;j<Lenfre;j++)
                {
                    if(j==0)
                    {
                        transPCentre(j,j) =  sat_ionP;
                        transQCentre(j,j) =  sat_ionQ;
                    }
                    else
                    {
                        transPCentre(j,j) =  sat_ambP;
                        transQCentre(j,j) =  sat_ambQ;
                    }
                }
                tempPk_2.block(0,0,freIn,freIn) = tempPk_1.block(0,0,freIn,freIn);
                tempPk_2.block(freIn+Lenfre,freIn+Lenfre,Pkcols-freIn,Pkcols-freIn) = tempPk_1.block(freIn,freIn,Pkcols-freIn,Pkcols-freIn);
                tempPk_2.block(0,freIn+Lenfre,freIn,Pkcols-freIn) = tempPk_1.block(0,freIn,freIn,Pkcols-freIn);
                tempPk_2.block(freIn+Lenfre,0,Pkcols-freIn,freIn) = tempPk_1.block(freIn,0,Pkcols-freIn,freIn);
                tempPk_2.block(freIn,freIn,Lenfre,Lenfre) = transPCentre;
                int Pk2cols=tempPk_2.cols();
                tempPk_1.resize(Pk2cols,Pk2cols);
                tempPk_1 = tempPk_2;
                tempQk_2.block(0,0,freIn,freIn) = tempQk_1.block(0,0,freIn,freIn);
                tempQk_2.block(freIn+Lenfre,freIn+Lenfre,Qk1cols-freIn,Qk1cols-freIn) = tempQk_1.block(freIn,freIn,Qk1cols-freIn,Qk1cols-freIn);
                tempQk_2.block(freIn,freIn,Lenfre,Lenfre) = transQCentre;
                int Qk2cols = tempQk_2.cols();
                tempQk_1.resize(Qk2cols,Qk2cols);
                tempQk_1 = tempQk_2;
            }

        }
        else if(oneStalit.cycly_slipF == 1)
        {
            int frequetN = 1;
            for(int j=0;j<5;j++)
            {
                if(oneStalit.ObsFreflag[j]==1)
                {
                    tempXk_1(freIn+frequetN) = (oneStalit.CodeP[j] - oneStalit.PhaseL[j])/(M_C/oneStalit.Frq[j]);
                    frequetN++;
                }
            }
            for(int k=0;k<tempXk_1.size();k++)
            {
                for(int j=0;j<Lenfre;j++)
                {
                    if(k == freIn &&j==0)
                        tempPk_1(freIn+j,freIn+j) =  sat_ionP;
                    else if(k == freIn+j)
                        tempPk_1(freIn+j,freIn+j) =  sat_ambP;
                    else
                    {
                        tempPk_1(freIn+j,k) = 0;
                        tempPk_1(k,freIn+j) = 0;
                    }
                }
            }
        }
        freIn = freIn + Lenfre;

    }
    int Pkcols=tempPk_1.cols();
    if(Covar_P.cols()!=Pkcols)
        return;
    Covar_P = tempPk_1;
    State_X = tempXk_1;
    Nois_Q = tempQk_1;
    m_VarChang = true;
}
// update Rk(Observation Covariance)
void coefficient_matrix::update_IF_Rk(QVector< SatlitData > &current_Sat, int B_len)
{
    int Avai_satN = current_Sat.length();
    Covar_Rk.resize(B_len, B_len);// this m_Rk_1 is for ISB
    Covar_Rk.setIdentity();// this m_Rk_1 is for ISB
    for (int i = 0;i < Avai_satN;i++)
    {
        SatlitData oneSatlit = current_Sat.at(i);
        /*Covariance of carrier equation Reciprocal (small noise)// 1/25000 =4e-4*/
        Covar_Rk(i*2,i*2) = 1.0/(oneSatlit.SatWight*whihet_diff*oneSatlit.SatWight_IF[0]);
        Covar_Rk(i*2+1,i*2+1) = 1.0/(oneSatlit.SatWight*oneSatlit.SatWight_IF[1]);
    }
}
// update Rk(Observation Covariance)
void coefficient_matrix::update_NoCombination_Rk(QVector< SatlitData > &current_Sat, int B_len)
{
    int Avai_satN = current_Sat.length();
    Covar_Rk.resize(B_len, B_len);// this m_Rk_1 is for ISB
    Covar_Rk.setIdentity();// this m_Rk_1 is for ISB
    int column_pos=0;
    for (int i = 0;i < Avai_satN;i++)
    {
        SatlitData oneSatlit = current_Sat.at(i);
        for(int mufre=0;mufre<5;mufre++)
        {
            if(oneSatlit.ObsFreflag[mufre]!=1)  continue;
            /*Covariance of carrier equation Reciprocal (small noise)// 1/25000 =4e-4*/
            Covar_Rk(column_pos*2,column_pos*2) = 1.0/(oneSatlit.SatWight*whihet_diff*oneSatlit.SatWight_UD[mufre*2]);
            Covar_Rk(column_pos*2+1,column_pos*2+1) = 1.0/(oneSatlit.SatWight*oneSatlit.SatWight_UD[mufre*2+1]);
            column_pos++;
        }
    }
}
//Determine whether the number of satellites has changed (comparison of two epochs before and after)   debug by xiaogongwei 2019.04.29
bool coefficient_matrix::isSatelliteChange(QVector< SatlitData > &preEpoch,QVector< SatlitData > &currEpoch, QVector< int > &oldPrnFlag,QVector< int > &NewPrnFlag)
{
    int preEpochLen = preEpoch.length();
    int epochLenLB = currEpoch.length();
    //Determine whether the number of satellites has changed (comparison of two epochs before and after)
    int oldSatLen = 0;
    bool isNewSatlite = false;
    for (int i = 0;i < epochLenLB;i++)
    {//Whether the satellite inspections before and after the cycle are completely equal
        SatlitData epochSatlit = currEpoch.at(i);
        bool Isfind = false;//Whether the tag finds the last epoch
        for (int j = 0;j < preEpochLen;j++)
        {
            SatlitData preEpochSatlit = preEpoch.at(j);
            if (epochSatlit.PRN == preEpochSatlit.PRN&&epochSatlit.SatType == preEpochSatlit.SatType)
            {
                oldPrnFlag.append(j);//Compared with the location of the same satellite in the previous epoch, it is not found with -1
                Isfind = true;
                oldSatLen++;
                break;
            }
        }
        if (!Isfind)
        {
            oldPrnFlag.append(-1);//Compared with the location of the same satellite in the previous epoch, it is not found with -1
            isNewSatlite = true;
        }
        if(epochSatlit.cycly_slipF==1)
            isNewSatlite = true;
    }
    for (int i = 0;i < preEpochLen;i++)
    {//Whether the satellite inspections before and after the cycle are completely equal
        SatlitData preEpochSatlit = preEpoch.at(i);
        bool Isfind = false;//Whether the tag finds the last epoch
        for (int j = 0;j < epochLenLB;j++)
        {
            SatlitData epochSatlit = currEpoch.at(j);
            if (epochSatlit.PRN == preEpochSatlit.PRN&&epochSatlit.SatType == preEpochSatlit.SatType)
            {
                NewPrnFlag.append(j);//Compared with the location of the same satellite in the previous epoch, it is not found with -1
                Isfind = true;
                break;
            }
        }
        if (!Isfind)
        {
            NewPrnFlag.append(-1);//Compared with the location of the same satellite in the previous epoch, it is not found with -1
        }
    }
    return isNewSatlite;
}
// get matrix B and observer L for IF Combination
void coefficient_matrix::Obtaining_SPP_IF_equation(QVector< SatlitData > &Current_sat, double *m_ApproxRecPos, MatrixXd &mat_B, VectorXd &Vct_L,
                             MatrixXd &mat_P)
{
    int Avai_satN = Current_sat.length();
    MatrixXd B, P;
    VectorXd L;
    B.resize(Avai_satN,3+sys_num);
    P.resize(Avai_satN,Avai_satN);
    L.resize(Avai_satN);
    B.setZero(Avai_satN,3+sys_num);
    L.setZero(Avai_satN);
    P.setIdentity();
    for (int i = 0; i < Avai_satN;i++)
    {
        SatlitData oneSatlit = Current_sat.at(i);
        double XYZ_coef[3],p0 = 0,satXYZ[3]={oneSatlit.X,oneSatlit.Y,oneSatlit.Z};
//        p0 = m_mat_cal.geodist(satXYZ,m_ApproxRecPos,XYZ_coef);
        double li = 0,mi = 0,ni = 0,dltaX = 0,dltaY = 0,dltaZ = 0;
        dltaX = oneSatlit.X - m_ApproxRecPos[0];
        dltaY = oneSatlit.Y - m_ApproxRecPos[1];
        dltaZ = oneSatlit.Z - m_ApproxRecPos[2];
        p0 = qSqrt(dltaX*dltaX+dltaY*dltaY+dltaZ*dltaZ);
        // compute li mi ni
        li = dltaX/p0;mi = dltaY/p0;ni = dltaZ/p0;
        //Correction of each
        double dlta = 0;
        dlta =  - oneSatlit.StaClock + oneSatlit.SatTrop - oneSatlit.Relativty -
            oneSatlit.Sagnac - oneSatlit.TideEffect - oneSatlit.AntHeight;
        // set B L P
//        for(int j=0;j<3;j++)
//        {
//            B(i,j) = XYZ_coef[j];
//        }
        B(i,0) = li;B(i,1) = mi;B(i,2) = ni;
//        B(i,3) = -oneSatlit.StaTropMap;
        int clkref=0;
        for(int j=0;j<m_sys_str.length();j++)
        {
            if(m_sys_str[j] == oneSatlit.SatType)
            {
                B(i,3+clkref) = -1;
            }
            if(sys_len[j] == 1) clkref++;
        }
        //Carrier L  pseudorange code L
        L(i) = p0 - oneSatlit.IF_P + dlta;
        // Computing weight matrix P
        P(i, i) = oneSatlit.SatWight;// Carrier L1 weight
    }
    mat_B = B;
    Vct_L = L;
    mat_P = P;
}
// get matrix B and observer L for No Combination
void coefficient_matrix::Obtaining_SPP_NoCombination_equation(QVector< SatlitData > &Current_sat, double *m_ApproxRecPos, MatrixXd &mat_B, VectorXd &Vct_L,
                             MatrixXd &mat_P,int Total_sat_fre)
{
    int Avai_satN = Current_sat.length();
    MatrixXd B, P;
    VectorXd L;
    B.resize(Total_sat_fre,3+sys_num);
    P.resize(Total_sat_fre,Total_sat_fre);
    L.resize(Total_sat_fre);
    B.setZero(Total_sat_fre,3+sys_num);
    L.setZero(Total_sat_fre);
    P.setIdentity();
    int column_pos =0;
    for (int i = 0; i < Avai_satN;i++)
    {
        SatlitData oneSatlit = Current_sat.at(i);
        double XYZ_coef[3],p0 = 0,satXYZ[3]={oneSatlit.X,oneSatlit.Y,oneSatlit.Z};
        p0 = m_mat_cal.geodist(satXYZ,m_ApproxRecPos,XYZ_coef);
        //Correction of each
        double dlta = 0;
        dlta =  - oneSatlit.StaClock + oneSatlit.SatTrop - oneSatlit.Relativty -
            oneSatlit.Sagnac - oneSatlit.TideEffect - oneSatlit.AntHeight;
        // set B L P
        for(int mufre=0;mufre<5;mufre++)
        {
            if(oneSatlit.ObsFreflag[mufre]!=1)  continue;
            for(int j=0;j<3;j++)
            {
                B(column_pos,j) = XYZ_coef[j];
            }
            B(column_pos,3) = -oneSatlit.StaTropMap;
            int clkref=0;
            for(int j=0;j<m_sys_str.length();j++)
            {
                if(m_sys_str[j] == oneSatlit.SatType)
                {
                    B(column_pos,3+clkref) = -1;
                }
                if(sys_len[j] == 1) clkref++;
            }
            //Carrier L  pseudorange code L
            L(column_pos) = p0 - oneSatlit.CodePP[mufre] + dlta + oneSatlit.SatIon[mufre];
            // Computing weight matrix P
            P(column_pos, column_pos) = oneSatlit.SatWight;// Carrier L1 weight
            column_pos++;
        }

    }//B, L is calculated
    // save data to mat_B
    mat_B = B;
    Vct_L = L;
    mat_P = P;

}
/*Initialize the satellites in the suspect domain*/
void coefficient_matrix::Domain_of_doubt_IF(QVector< SatlitData > &preEpoch,QVector< SatlitData > &current_Sat)
{
    int preEpochLen = preEpoch.length();
    int epochLenLB = current_Sat.length();
    QVector< SatlitData > Domain_sat;
    //Determine whether the number of satellites has changed (comparison of two epochs before and after)
    for (int i = 0;i < epochLenLB;i++)
    {//Whether the satellite inspections before and after the cycle are completely equal
        SatlitData epochSatlit = current_Sat.at(i);
        for (int j = 0;j < preEpochLen;j++)
        {
            SatlitData preEpochSatlit = preEpoch.at(j);
            if (epochSatlit.PRN == preEpochSatlit.PRN&&epochSatlit.SatType == preEpochSatlit.SatType)
            {
                if(preEpochSatlit.Domain_of_doubt==-1)
                {
                    State_X(i+const_parm) = (epochSatlit.IF_P - epochSatlit.IF_L)/M_GetLamta3(epochSatlit.Frq[epochSatlit.IF_Frq[0]],epochSatlit.Frq[epochSatlit.IF_Frq[1]]);
                    epochSatlit.SatWight_IF[0]= preEpochSatlit.SatWight_IF[0];
                    epochSatlit.SatWight_IF[1]= preEpochSatlit.SatWight_IF[1];
                    for(int n=0;n<Covar_P.cols();n++)
                    {
                        if(i+const_parm!=n)
                            Covar_P(i+const_parm,n) = Covar_P(n,i+const_parm) = 0.0;
                        else
                            Covar_P(n,n) = sat_ambP;
                    }
                }
                break;
            }
        }
        Domain_sat.append(epochSatlit);
    }
    if(Domain_sat.length() == current_Sat.length())
        current_Sat = Domain_sat;
    Domain_sat.clear();
}
/*Initialize the satellites in the suspect domain*/
void coefficient_matrix::Domain_of_doubt_NoCom(QVector< SatlitData > &preEpoch,QVector< SatlitData > &current_Sat)
{
    int preEpochLen = preEpoch.length();
    int epochLenLB = current_Sat.length();
    //Determine whether the number of satellites has changed (comparison of two epochs before and after)
    int con_Num = 0;
    for (int i = 0;i < epochLenLB;i++)
    {//Whether the satellite inspections before and after the cycle are completely equal
        SatlitData epochSatlit = current_Sat.at(i);
        for (int j = 0;j < preEpochLen;j++)
        {
            SatlitData preEpochSatlit = preEpoch.at(j);
            if (epochSatlit.PRN == preEpochSatlit.PRN&&epochSatlit.SatType == preEpochSatlit.SatType)
            {
                if(preEpochSatlit.Domain_of_doubt==-1)
                {
                    int init_Pos = con_Num + 1;
//                    for(int n=0;n<Covar_P.cols();n++)
//                    {
//                        if(n!=con_Num)
//                            Covar_P(con_Num,n) = Covar_P(n,con_Num) = 0.0;
//                        else
//                            Covar_P(n,n) = sat_ionP;
//                    }
                    for(int mufre=0;mufre<5;mufre++)
                    {
                        if(epochSatlit.ObsFreflag[mufre]!=1)  continue;
                        epochSatlit.SatWight_UD[mufre*2]= preEpochSatlit.SatWight_UD[mufre*2];
                        epochSatlit.SatWight_UD[mufre*2+1]= preEpochSatlit.SatWight_UD[mufre*2+1];
//                        State_X(init_Pos) = (epochSatlit.CodeP[mufre] - epochSatlit.PhaseL[mufre])/(M_C/epochSatlit.Frq[mufre]);
//                        for(int n=0;n<Covar_P.cols();n++)
//                        {
//                            if(init_Pos+const_parm!=n)
//                                Covar_P(init_Pos+const_parm,n) = Covar_P(n,init_Pos+const_parm) = 0.0;
//                            else
//                                Covar_P(n,n) = sat_ambP;
//                        }
//                        init_Pos++;
                    }
                }
                break;
            }
        }
        con_Num++;
        for(int mufre=0;mufre<5;mufre++)
        {
            if(epochSatlit.ObsFreflag[mufre]!=1)  continue;
            con_Num++;
        }

    }
}
